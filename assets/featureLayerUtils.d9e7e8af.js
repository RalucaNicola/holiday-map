import{s as L,x as m,eR as w,bX as F,C as n,eS as R,eT as f,eU as d,eV as D,K as U,cH as Y,w as _,eW as q,cJ as z,es as B,r as $,eX as C,eY as g}from"./vendor.c414a8c9.js";import{fetchFeatureService as M}from"./arcgisLayers.984783ce.js";import{o as v}from"./jsonContext.c7b85d5c.js";import"./lazyLayerLoader.aa9f34a2.js";const j=L.getLogger("esri.layers.FeatureLayer"),y="Feature Service";function c(e,a){return`Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${a}`}function N(e,a){if(a.type!==y)throw new n("feature-layer:portal-item-wrong-type",c(e,`should have portal item of type "${y}"`))}async function O(e){if(await e.load(),R(e))throw new n("feature-layer:save",c(e,"using an in-memory source cannot be saved to a portal item"))}function G(e,a){let t=e.messages.filter(({type:r})=>r==="error").map(({name:r,message:s,details:o})=>new n(r,s,o));if((a==null?void 0:a.ignoreUnsupported)&&(t=t.filter(({name:r})=>r!=="layer:unsupported"&&r!=="symbol:unsupported"&&r!=="symbol-layer:unsupported"&&r!=="property:unsupported"&&r!=="url:unsupported")),t.length>0)throw new n("feature-layer:save","Failed to save feature layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:t})}async function h(e,a,t){"beforeSave"in e&&typeof e.beforeSave=="function"&&await e.beforeSave();const r=e.write({},a);return G(a,t),r}function T(e){const{layer:a,layerJSON:t}=e;return a.isTable?{layers:[],tables:[t]}:{layers:[t],tables:[]}}function b(e){f(e,d.JSAPI),e.typeKeywords&&(e.typeKeywords=e.typeKeywords.filter((a,t,r)=>r.indexOf(a)===t))}function X(e){const a=e.portalItem;if(!a)throw j.error("save: requires the portalItem property to be set"),new n("feature-layer:portal-item-not-set",c(e,"requires the portalItem property to be set"));if(!a.loaded)throw new n("feature-layer:portal-item-not-loaded",c(e,"cannot be saved to a portal item that does not exist or is inaccessible"));N(e,a)}async function x(e,a){return/\/\d+\/?$/.test(e.url)?T(a[0]):H(e,a)}async function H(e,a){const{layer:{url:t,customParameters:r,apiKey:s}}=a[0];let o=await e.fetchData("json");o&&o.layers!=null&&o.tables!=null||(o=await V(o,{url:t,customParameters:r,apiKey:s},a.map(l=>l.layer.layerId)));for(const l of a)E(l.layer,l.layerJSON,o);return o}async function V(e,a,t){var r,s;e||(e={}),(r=e).layers||(r.layers=[]),(s=e).tables||(s.tables=[]);const{url:o,customParameters:l,apiKey:i}=a,{serviceJSON:u,layersJSON:p}=await M(o,{customParameters:l,apiKey:i}),S=J(e.layers,u.layers,t),I=J(e.tables,u.tables,t);e.layers=S.itemResources,e.tables=I.itemResources;const K=[...S.added,...I.added],P=p?[...p.layers,...p.tables]:[];return await W(e,K,o,P),e}function J(e,a,t){const r=D(e,a,(o,l)=>o.id===l.id);e=e.filter(o=>!r.removed.some(l=>l.id===o.id));const s=r.added.map(({id:o})=>({id:o}));return s.forEach(({id:o})=>{e.push({id:o})}),{itemResources:e,added:s.filter(({id:o})=>!t.includes(o))}}async function W(e,a,t,r){const s=a.map(({id:o})=>new U({url:t,layerId:o,sourceJSON:r.find(({id:l})=>l===o)}));await Y(s.map(o=>o.load())),s.forEach(o=>{const{layerId:l,loaded:i,defaultPopupTemplate:u}=o;!i||_(u)||E(o,{id:l,popupInfo:u.toJSON()},e)})}function E(e,a,t){e.isTable?A(t.tables,a):A(t.layers,a)}function A(e,a){const t=e.findIndex(({id:r})=>r===a.id);t===-1?e.push(a):e[t]=a}function k(e){const{portalItem:a}=e;return q(e)&&!e.dynamicDataSource&&!!(a==null?void 0:a.loaded)&&a.type===y}async function Q(e){if(!(e==null?void 0:e.length))throw new n("feature-layer-utils-saveall:missing-parameters","'layers' array should contain at least one feature layer");await Promise.all(e.map(r=>r.load()));for(const r of e)if(!k(r))throw new n("feature-layer-utils-saveall:invalid-parameters",`'layers' array should only contain layers or tables in a feature service loaded from 'Feature Service' item. ${c(r,"does not conform")}`,{layer:r});const a=e.map(r=>r.portalItem.id);if(new Set(a).size>1)throw new n("feature-layer-utils-saveall:invalid-parameters","All layers in the 'layers' array should be loaded from the same portal item");const t=e.map(r=>r.layerId);if(new Set(t).size!==t.length)throw new n("feature-layer-utils-saveall:invalid-parameters","'layers' array should contain only one instance each of layer or table in a feature service")}function Z(e,a){var o,l;var t,r;let s=z.from(a);return s.id&&(s=s.clone(),s.id=null),(o=(t=s).type)!=null||(t.type=y),(l=(r=s).portal)!=null||(r.portal=F.getDefault()),N(e,s),s}async function ee(e,a){const{url:t,layerId:r,title:s,fullExtent:o,isTable:l}=e,i=B(t),u=$(i)&&i.serverType==="FeatureServer";a.url=u?t:`${t}/${r}`,a.title||(a.title=s),a.extent=null,!l&&$(o)&&(a.extent=await C(o)),g(a,d.METADATA),g(a,d.MULTI_LAYER),f(a,d.SINGLE_LAYER),l&&f(a,d.TABLE),b(a)}async function ae(e,a,t){const r=e.portal;await r._signIn(),await r.user.addItem({item:e,data:a,folder:t==null?void 0:t.folder})}const ie=m(te);async function te(e,a){await O(e),X(e);const t=e.portalItem,r=v(t),s=await h(e,r,a),o=await x(t,[{layer:e,layerJSON:s}]);return b(t),await t.update({data:o}),w(r),t}const ue=m(async(e,a)=>{await Q(e);const t=e[0].portalItem,r=v(t),s=await Promise.all(e.map(l=>h(l,r,a))),o=await x(t,e.map((l,i)=>({layer:l,layerJSON:s[i]})));return b(t),await t.update({data:o}),await Promise.all(e.slice(1).map(l=>l.portalItem.reload())),w(r),t.clone()}),de=m(re);async function re(e,a,t){await O(e);const r=Z(e,a),s=v(r),o=T({layer:e,layerJSON:await h(e,s,t)});return await ee(e,r),await ae(r,o,t),e.portalItem=r,w(s),r}export{ie as save,ue as saveAll,de as saveAs};
