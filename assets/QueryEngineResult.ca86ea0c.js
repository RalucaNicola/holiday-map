var ce=Object.defineProperty,de=Object.defineProperties;var he=Object.getOwnPropertyDescriptors;var H=Object.getOwnPropertySymbols;var fe=Object.prototype.hasOwnProperty,me=Object.prototype.propertyIsEnumerable;var Y=(l,e,t)=>e in l?ce(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,M=(l,e)=>{for(var t in e||(e={}))fe.call(e,t)&&Y(l,t,e[t]);if(H)for(var t of H(e))me.call(e,t)&&Y(l,t,e[t]);return l},U=(l,e)=>de(l,he(e));import{gn as X,C as b,w as ne,bJ as ge,bK as k,r as J,go as K,gp as pe,gq as W,aO as ye,gr as xe,d8 as Fe}from"./vendor.c414a8c9.js";import{s as ee}from"./quantizationUtils.2450b4c7.js";import{WhereClause as Ie}from"./WhereClause.86ae959e.js";import{T as Ve,s as _e,m as te,c as se,V as Te,g as ve,h as ze,y as be,D as Ae,z as Se,f as we,d as De}from"./utils.791af34e.js";import{g as ie}from"./projectionSupport.441f613a.js";import{x as P,J as O,O as ae}from"./utils.acea15e5.js";class Ee{constructor(e,t){this._cache=new X(e),this._invalidCache=new X(t)}get(e,t){const s=`${t.uid}:${e}`,n=this._cache.get(s);if(n)return n;if(this._invalidCache.get(s)!==void 0)return null;try{const i=Ie.create(e,t);return this._cache.put(s,i),i}catch{return this._invalidCache.put(s,null),null}}}const j=new Ee(50,500),A="feature-store:unsupported-query",re=" as ",Ce=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Ze(l,e){if(!e)return!0;const t=j.get(e,l);if(!t)throw new b(A,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new b(A,"where clause is not standard",{where:e});return Q(l,t.fieldNames,"where clause contains missing fields"),!0}function Le(l,e,t){if(!e)return!0;const s=j.get(e,l);if(!s)throw new b(A,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new b(A,"having does not contain a valid aggregate function",{having:e});const n=s.fieldNames;if(Q(l,n,"having contains missing fields"),!s.getExpressions().every(i=>{const{aggregateType:a,field:r}=i,o=l.has(r)&&l.get(r).name;return t.some(u=>{const{onStatisticField:c,statisticType:f}=u;return(l.has(c)&&l.get(c).name)===o&&f.toLowerCase().trim()===a})}))throw new b(A,"expressions in having should also exist in outStatistics",{having:e});return!0}function R(l,e){return l?j.get(l,e):null}function Q(l,e,t,s=!0){const n=[];for(const i of e)if(i!=="*"&&!l.has(i))if(s){const a=oe(i);try{const r=R(a,l);if(!r)throw new b(A,"invalid SQL expression",{where:a});if(!r.isStandardized)throw new b(A,"expression is not standard",{clause:r});Q(l,r.fieldNames,"expression contains missing fields")}catch(r){const o=r&&r.details;if(o&&(o.clause||o.where))throw r;o&&o.missingFields?n.push(...o.missingFields):n.push(i)}}else n.push(i);if(n.length)throw new b(A,t,{missingFields:n})}function oe(l){return l.split(re)[0]}function Re(l){return l.split(re)[1]}function Be(l,e){const t=e.get(l);return!!t&&!Ce.has(t.type)}class ${constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=s,this.featureAdapter=t;const n=e.outFields;if(n&&!n.includes("*")){this.outFields=n;let i=0;for(const a of n){const r=oe(a),o=this.fieldsIndex.get(r),u=o?null:R(r,s),c=o?o.name:Re(a)||"FIELD_EXP_"+i++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){const n=s?s.name:t;let i=null;return this._fieldDataCache.has(n)?i=this._fieldDataCache.get(n).clause:s||(i=R(t,this.fieldsIndex),this._fieldDataCache.set(n,{alias:n,clause:i})),s?this.featureAdapter.getAttribute(e,n):i.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const s=t.normalizationType,n=t.normalizationTotal;let i=this.getFieldValue(e,t.field,t.fieldInfo);if(s&&Number.isFinite(i)){const a=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);i=Ve(i,s,a,n)}return i}getExpressionValue(e,t,s,n){const i={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},a=n.createExecContext(i,s);return n.executeFunction(t,a)}getExpressionValues(e,t,s,n){const i={fields:this.fieldsIndex.fields};return e.map(a=>{const r={attributes:this.featureAdapter.getAttributes(a),layer:i},o=n.createExecContext(r,s);return n.executeFunction(t,o)})}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:R(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:R(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const n of t){const{alias:i,clause:a}=this._fieldDataCache.get(n);s[i]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,i)}return s}_processAttributesForDistinctValues(e){if(ne(e)||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const a of t){const{alias:r}=this._fieldDataCache.get(a);s.push(e[r])}else for(const a in e)s.push(e[a]);const n=`${(t||["*"]).join(",")}=${s.join(",")}`;let i=this._returnDistinctMap.get(n)||0;return this._returnDistinctMap.set(n,++i),i>1?null:e}}class He{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new $(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:n}=this.query;if(!(t==null?void 0:t.length))return 1;const a=new Map,r=new Map,o=new Set;for(const u of n){const{statisticType:c}=u,f=c!=="exceedslimit"?u.onStatisticField:void 0;if(!r.has(f)){const d=[];for(const h of t){const F=this._getAttributeValues(e,h,a);d.push(F)}r.set(f,this._calculateUniqueValues(d,e.returnDistinctValues))}const m=r.get(f);for(const d in m){const{data:h,items:F}=m[d],I=h.join(",");s&&!e.validateItems(F,s)||o.add(I)}}return o.size}async createQueryResponse(){let e;return this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(ge(this.query.outSR)&&!k(this.query.geometry.spatialReference,this.query.outSR)?e.queryGeometry=P(M({spatialReference:this.query.outSR},ie(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR))):e.queryGeometry=P(M({spatialReference:this.query.outSR},this.query.geometry))),e}createSnappingResponse(e,t){const s=this.featureAdapter,n=qe(this.hasZ,this.hasM),{x:i,y:a}=e.point,r=typeof e.distance=="number"?e.distance:e.distance.x,o=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",f=this._getPointCreator(e.point,this.spatialReference,t);for(const m of this.items){const d=s.getGeometry(m);if(ne(d))continue;const{coords:h,lengths:F}=d;if(e.types&G.EDGE){let I=0;for(let y=0;y<F.length;y++){const V=F[y];for(let x=0;x<V;x++,I+=n){const _=h[I],p=h[I+1];if(x!==V-1){const g=h[I+n],S=h[I+n+1],{x:C,y:N}=Ne(i,a,_,p,g,S),T=(i-C)/r,v=(a-N)/o,w=T*T+v*v;w<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(m),distance:Math.sqrt(w),target:f(C,N),start:f(_,p),end:f(g,S)})}}}}if(e.types&G.VERTEX){const I=c?h.length-n:h.length;for(let y=0;y<I;y+=n){const V=h[y],x=h[y+1],_=(i-V)/r,p=(a-x)/o,g=_*_+p*p;g<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(m),distance:Math.sqrt(g),target:f(V,x)})}}}return u.candidates.sort((m,d)=>m.distance-d.distance),u}_getPointCreator(e,t,s){const n=J(s)&&!k(t,s)?i=>ie(i,t,s):i=>i;return e.z!=null&&e.m!=null?(i,a)=>n({x:i,y:a,z:e.z,m:e.m}):e.z!=null?(i,a)=>n({x:i,y:a,z:e.z}):e.m!=null?(i,a)=>n({x:i,y:a,m:e.m}):(i,a)=>n({x:i,y:a})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,minValue:r,maxValue:o,scale:u}=e,c=this.fieldsIndex.isDateField(t),f=await this._getDataValues({field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,scale:u}),m=_e({normalizationType:i,normalizationField:n,minValue:r,maxValue:o}),d=this.fieldsIndex.get(t),h={value:.5,fieldType:d==null?void 0:d.type},F=K(d)?te({values:f,supportsNullCount:m,percentileParams:h}):se({values:f,minValue:r,maxValue:o,useSampleStdDev:!i,supportsNullCount:m,percentileParams:h});return Te(F,c)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domain:n,returnAllCodedValues:i,scale:a}=e,r=await this._getDataValues({field:t,valueExpression:s,scale:a}),o=ve(r);return ze(o,n,i)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:f,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,scale:m}),h=be(d,{field:t,normalizationField:n,normalizationType:i,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:f});return Ae(h,r)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:f,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:n,normalizationType:i,normalizationTotal:a,scale:m});return Se(d,{field:t,normalizationField:n,normalizationType:i,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:f})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const n of t.reverse()){const i=n.split(" "),a=i[0],r=this.fieldsIndex.get(a),o=i[1]&&i[1].toLowerCase()==="desc",u=we(r==null?void 0:r.type,o);e.sort((c,f)=>{const m=s(c,a,r),d=s(f,a,r);return u(m,d)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:n,hasZ:i,objectIdField:a,spatialReference:r}=this,{outFields:o,outSR:u,quantizationParameters:c,resultRecordCount:f,resultOffset:m,returnZ:d,returnM:h}=e,F=f!=null&&t.length>(m||0)+f,I=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:F,features:this._createFeatures(e,t),fields:I,geometryType:s,hasM:n&&h,hasZ:i&&d,objectIdFieldName:a,spatialReference:P(u||r),transform:c&&ee(c)||null}}_createFeatures(e,t){const s=new $(e,this.featureAdapter,this.fieldsIndex),{hasM:n,hasZ:i}=this,{orderByFields:a,quantizationParameters:r,returnGeometry:o,returnCentroid:u,maxAllowableOffset:c,resultOffset:f,resultRecordCount:m,returnZ:d=!1,returnM:h=!1}=e,F=i&&d,I=n&&h;let y=[],V=0;const x=[...t];if(this._sortFeatures(x,a,(p,g,S)=>s.getFieldValue(p,g,S)),o||u){const p=ee(r);if(o&&!u)for(const g of x)y[V++]={attributes:s.getAttributes(g),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,p,F,I)};else if(!o&&u)for(const g of x)y[V++]={attributes:s.getAttributes(g),centroid:ae(this,this.featureAdapter.getCentroid(g,this),p)};else for(const g of x)y[V++]={attributes:s.getAttributes(g),centroid:ae(this,this.featureAdapter.getCentroid(g,this),p),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,p,F,I)}}else for(const p of x){const g=s.getAttributes(p);g&&(y[V++]={attributes:g})}const _=f||0;if(m!=null){const p=_+m;y=y.slice(_,Math.min(y.length,p))}return y}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY;for(const a of e.outStatistics)if(a.statisticType==="exceedslimit"){s=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,n=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,i=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>n)t=!0;else{const a=this.hasZ?this.hasM?4:3:this.hasM?3:2,r=this.featureAdapter;t=this.items.reduce((o,u)=>{const c=r.getGeometry(u);return o+(J(c)&&c.coords.length||0)},0)/a>i}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],n=new Map,i=new Map,a=new Map,r=new Map,o=new $(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:f,orderByFields:m}=e,d=c&&c.length,h=!!d,F=h&&c[0],I=h&&!this.fieldsIndex.get(F);for(const V of u){const{outStatisticFieldName:x,statisticType:_}=V,p=V,g=_!=="exceedslimit"?V.onStatisticField:void 0,S=_==="percentile_disc"||_==="percentile_cont",C=_==="EnvelopeAggregate"||_==="CentroidAggregate"||_==="ConvexHullAggregate",N=h&&d===1&&(g===F||I)&&_==="count";if(h){if(!a.has(g)){const v=[];for(const w of c){const q=this._getAttributeValues(o,w,n);v.push(q)}a.set(g,this._calculateUniqueValues(v,o.returnDistinctValues))}const T=a.get(g);for(const v in T){const{count:w,data:q,items:Z,itemPositions:le}=T[v],L=q.join(",");if(!f||o.validateItems(Z,f)){const D=r.get(L)||{attributes:{}};if(C){D.aggregateGeometries||(D.aggregateGeometries={});const{aggregateGeometries:z,outStatisticFieldName:E}=await this._getAggregateGeometry(p,Z);D.aggregateGeometries[E]=z}else{let z=null;if(N)z=w;else{const E=this._getAttributeValues(o,g,n),B=le.map(ue=>E[ue]);z=S&&"statisticParameters"in p?this._getPercentileValue(p,B):this._getStatisticValue(p,B,null,o.returnDistinctValues)}D.attributes[x]=z}c.forEach((z,E)=>D.attributes[this.fieldsIndex.get(z)?z:`EXPR_${E+1}`]=q[E]),r.set(L,D)}}}else if(C){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:T,outStatisticFieldName:v}=await this._getAggregateGeometry(p,this.items);t.aggregateGeometries[v]=T}else{const T=this._getAttributeValues(o,g,n);t.attributes[x]=S&&"statisticParameters"in p?this._getPercentileValue(p,T):this._getStatisticValue(p,T,i,o.returnDistinctValues)}s.push({name:x,alias:x,type:"esriFieldTypeDouble"})}const y=h?Array.from(r.values()):[t];return this._sortFeatures(y,m,(V,x)=>V.attributes[x]),{fields:s,features:y}}async _getAggregateGeometry(e,t){const s=await import("./geometryEngineJSON.55e81d9a.js"),{statisticType:n,outStatisticFieldName:i}=e,{featureAdapter:a,spatialReference:r,geometryType:o,hasZ:u,hasM:c}=this,f=t.map(h=>O(o,u,c,a.getGeometry(h))),m=s.convexHull(r,f,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(n==="EnvelopeAggregate"){const h=m?pe(m):W(s.union(r,f));d.aggregateGeometries=U(M({},h),{spatialReference:r}),d.outStatisticFieldName=i||"extent"}else if(n==="CentroidAggregate"){const h=m?ye(m):xe(W(s.union(r,f)));d.aggregateGeometries={x:h[0],y:h[1],spatialReference:r},d.outStatisticFieldName=i||"centroid"}else n==="ConvexHullAggregate"&&(d.aggregateGeometries=m,d.outStatisticFieldName=i||"convexHull");return d}_getStatisticValue(e,t,s,n){const{onStatisticField:i,statisticType:a}=e;let r=null;return r=(s==null?void 0:s.has(i))?s.get(i):K(this.fieldsIndex.get(i))?te({values:t,returnDistinct:n}):se({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(i,r),r[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:n,statisticType:i}=e,{value:a,orderBy:r}=n,o=this.fieldsIndex.get(s);return De(t,{value:a,orderBy:r,fieldType:o==null?void 0:o.type,isDiscrete:i==="percentile_disc"})}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const n=this.fieldsIndex.get(t),i=this.items.map(a=>e.getFieldValue(a,t,n));return s.set(t,i),i}_getAttributeNormalizedValues(e,t){return this.items.map(s=>e.getNormalizedValue(s,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:n}=await Fe(),i=n.createFunction(t),a=s&&n.getViewInfo(s);return e.getExpressionValues(this.items,i,a,n)}_calculateUniqueValues(e,t){const s={},n=this.items,i=n.length;for(let a=0;a<i;a++){const r=n[a],o=[];for(const c of e)o.push(c[a]);const u=o.join(",");t?s[u]==null&&(s[u]={count:1,data:o,items:[r],itemPositions:[a]}):s[u]==null?s[u]={count:1,data:o,items:[r],itemPositions:[a]}:(s[u].count++,s[u].items.push(r),s[u].itemPositions.push(a))}return s}async _getDataValues(e){const t=new $(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:n,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:o}=e,u=s?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(t,s,u):this._getAttributeNormalizedValues(t,{field:n,normalizationField:i,normalizationType:a,normalizationTotal:r})}}function Ne(l,e,t,s,n,i){const a=n-t,r=i-s,o=a*a+r*r,u=(l-t)*a+(e-s)*r,c=Math.min(1,Math.max(0,u/o));return{x:t+a*c,y:s+r*c}}function qe(l,e){return l?e?4:3:e?3:2}var G;(function(l){l[l.NONE=0]="NONE",l[l.EDGE=1]="EDGE",l[l.VERTEX=2]="VERTEX"})(G||(G={}));export{G as E,Le as a,Q as c,Be as f,R as l,Ze as o,He as v};
