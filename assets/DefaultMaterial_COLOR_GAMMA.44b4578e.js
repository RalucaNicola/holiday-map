var Ee=Object.defineProperty,Oe=Object.defineProperties;var Ne=Object.getOwnPropertyDescriptors;var ne=Object.getOwnPropertySymbols;var Ae=Object.prototype.hasOwnProperty,Ue=Object.prototype.propertyIsEnumerable;var oe=(n,e,t)=>e in n?Ee(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,h=(n,e)=>{for(var t in e||(e={}))Ae.call(e,t)&&oe(n,t,e[t]);if(ne)for(var t of ne(e))Ue.call(e,t)&&oe(n,t,e[t]);return n},se=(n,e)=>Oe(n,Ne(e));import{a as le}from"./vec33.cd12ce70.js";import{c as Ce,u as Re,r as Be,e as Me}from"./types.0bd8fc95.js";import{cD as pe,O as $e,lu as ye,w as me,U as Le,ix as ve,b5 as Fe,C as te,s as Pe,ex as he,k9 as Te,lv as De,cE as Ge,d$ as je,gZ as Ve,gU as ke,gT as Ye,hc as qe,iL as ze,r as re,gN as ae,aq as He,gK as Je,Y as B,$ as R,gE as C,ar as H,q as Xe,lj as Ke}from"./vendor.c414a8c9.js";import{e as be,r as xe}from"./mat4f64.a79dd289.js";import{D as K,L as Q,C as l,E as j}from"./enums.de935fa5.js";import{x as Qe}from"./quat.b252f462.js";import{e as We}from"./quatf64.ddec7ef6.js";import{B as Ze,g as et,d as tt,i as Z,c as ie,u as we,x as rt,L as nt,O as ot,E as st,F as at,w as it,q as ut,A as ct,V as dt}from"./BufferView.c86f5b8c.js";import{s as Se}from"./vectorStacks.2b1a501e.js";import{v as ft}from"./lineSegment.88ff172e.js";function lt(n,e,t){if(n.count!==e.count)return void le.error("source and destination buffers need to have the same number of elements");const o=n.count,r=t[0],s=t[1],a=t[2],c=t[3],u=t[4],i=t[5],d=t[6],f=t[7],p=t[8],y=t[9],m=t[10],w=t[11],M=t[12],_=t[13],S=t[14],g=t[15],T=n.typedBuffer,E=n.typedBufferStride,b=e.typedBuffer,$=e.typedBufferStride;for(let A=0;A<o;A++){const U=A*E,v=A*$,F=b[v],P=b[v+1],D=b[v+2],G=b[v+3];T[U]=r*F+u*P+p*D+M*G,T[U+1]=s*F+i*P+y*D+_*G,T[U+2]=a*F+d*P+m*D+S*G,T[U+3]=c*F+f*P+w*D+g*G}}function pt(n,e,t){if(n.count!==e.count)return void le.error("source and destination buffers need to have the same number of elements");const o=n.count,r=t[0],s=t[1],a=t[2],c=t[3],u=t[4],i=t[5],d=t[6],f=t[7],p=t[8],y=n.typedBuffer,m=n.typedBufferStride,w=e.typedBuffer,M=e.typedBufferStride;for(let _=0;_<o;_++){const S=_*m,g=_*M,T=w[g],E=w[g+1],b=w[g+2],$=w[g+3];y[S]=r*T+c*E+d*b,y[S+1]=s*T+u*E+f*b,y[S+2]=a*T+i*E+p*b,y[S+3]=$}}function yt(n,e){const t=Math.min(n.count,e.count),o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride;for(let c=0;c<t;c++){const u=c*r,i=c*a,d=s[i],f=s[i+1],p=s[i+2],y=d*d+f*f+p*p;if(y>0){const m=1/Math.sqrt(y);o[u]=m*d,o[u+1]=m*f,o[u+2]=m*p}}}function mt(n,e,t){const o=Math.min(n.count,e.count),r=n.typedBuffer,s=n.typedBufferStride,a=e.typedBuffer,c=e.typedBufferStride;for(let u=0;u<o;u++){const i=u*s,d=u*c;r[i]=t*a[d],r[i+1]=t*a[d+1],r[i+2]=t*a[d+2],r[i+3]=t*a[d+3]}}function ht(n,e,t){const o=Math.min(n.count,e.count),r=n.typedBuffer,s=n.typedBufferStride,a=e.typedBuffer,c=e.typedBufferStride;for(let u=0;u<o;u++){const i=u*s,d=u*c;r[i]=a[d]>>t,r[i+1]=a[d+1]>>t,r[i+2]=a[d+2]>>t,r[i+3]=a[d+3]>>t}}Object.freeze(Object.defineProperty({__proto__:null,transformMat4:lt,transformMat3:pt,normalize:yt,scale:mt,shiftRight:ht},Symbol.toStringTag,{value:"Module"}));function Tt(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d){for(let f=0;f<9;++f)o[u+f]=s[i+f];u+=r,i+=a}}Object.freeze(Object.defineProperty({__proto__:null,copy:Tt},Symbol.toStringTag,{value:"Module"}));function bt(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d){for(let f=0;f<16;++f)o[u+f]=s[i+f];u+=r,i+=a}}Object.freeze(Object.defineProperty({__proto__:null,copy:bt},Symbol.toStringTag,{value:"Module"}));function xt(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)o[u]=s[i],u+=r,i+=a}function J(n,e){const t=n.count;e||(e=new n.TypedArrayConstructor(t));for(let o=0;o<t;o++)e[o]=n.get(o);return e}Object.freeze(Object.defineProperty({__proto__:null,copy:xt,makeDense:J},Symbol.toStringTag,{value:"Module"}));function ge(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)o[u]=s[i],o[u+1]=s[i+1],u+=r,i+=a}function wt(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;if(Ce(e.elementType)){const d=Re(e.elementType);if(Be(e.elementType))for(let f=0;f<c;++f)o[u]=Math.max(s[i]/d,-1),o[u+1]=Math.max(s[i+1]/d,-1),u+=r,i+=a;else for(let f=0;f<c;++f)o[u]=s[i]/d,o[u+1]=s[i+1]/d,u+=r,i+=a}else ge(n,e,t);return n}function St(n,e,t,o){var u,i;const r=n.typedBuffer,s=n.typedBufferStride,a=(u=o==null?void 0:o.count)!=null?u:n.count;let c=((i=o==null?void 0:o.dstIndex)!=null?i:0)*s;for(let d=0;d<a;++d)r[c]=e,r[c+1]=t,c+=s}Object.freeze(Object.defineProperty({__proto__:null,copy:ge,normalizeIntegerBuffer:wt,fill:St},Symbol.toStringTag,{value:"Module"}));function gt(n,e,t){const o=n.typedBuffer,r=n.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)o[u]=s[i],o[u+1]=s[i+1],o[u+2]=s[i+2],o[u+3]=s[i+3],u+=r,i+=a}function It(n,e,t,o,r,s){var d,f;const a=n.typedBuffer,c=n.typedBufferStride,u=(d=s==null?void 0:s.count)!=null?d:n.count;let i=((f=s==null?void 0:s.dstIndex)!=null?f:0)*c;for(let p=0;p<u;++p)a[i]=e,a[i+1]=t,a[i+2]=o,a[i+3]=r,i+=c}Object.freeze(Object.defineProperty({__proto__:null,copy:gt,fill:It},Symbol.toStringTag,{value:"Module"}));function ur(n,e){return new n(new ArrayBuffer(e*n.ElementCount*Me(n.ElementType)))}class cr{constructor(e){this.streamDataRequester=e}async loadJSON(e,t){return this._load("json",e,t)}async loadBinary(e,t){return pe(e)?($e(t),ye(e)):this._load("binary",e,t)}async loadImage(e,t){return this._load("image",e,t)}async _load(e,t,o){if(me(this.streamDataRequester))return(await Le(t,{responseType:_t[e]})).data;const r=await ve(this.streamDataRequester.request(t,e,o));if(r.ok===!0)return r.value;throw Fe(r.error),new te("",`Request for resource failed: ${r.error}`)}}const _t={image:"image",binary:"array-buffer",json:"json"},Et=Pe.getLogger("esri.views.3d.glTF");class Ot{error(e){throw new te("gltf-loader-error",e)}errorUnsupported(e){throw new te("gltf-loader-unsupported-feature",e)}errorUnsupportedIf(e,t){e&&this.errorUnsupported(t)}assert(e,t){e||this.error(t)}warn(e){Et.warn(e)}warnUnsupported(e){this.warn("[Unsupported Feature] "+e)}warnUnsupportedIf(e,t){e&&this.warnUnsupported(t)}}function Nt(n={}){return h({color:[1,1,1],opacity:1,alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1,castShadows:!0,receiveShadows:!0,receiveAmbientOcclustion:!0,textureColor:null,textureNormal:null,textureOcclusion:null,textureEmissive:null,textureMetallicRoughness:null,emissiveFactor:[0,0,0],metallicFactor:1,roughnessFactor:1,colorMixMode:"multiply"},n)}function At(n,e={}){return{data:n,parameters:h({wrap:h({s:K.REPEAT,t:K.REPEAT},e.wrap),noUnpackFlip:!0,mipmap:!1},e)}}class ue{constructor(e){this.data=e,this.offset4=0,this.dataUint32=new Uint32Array(this.data,0,Math.floor(this.data.byteLength/4))}readUint32(){const e=this.offset4;return this.offset4+=1,this.dataUint32[e]}readUint8Array(e){const t=4*this.offset4;return this.offset4+=e/4,new Uint8Array(this.data,t,e)}remainingBytes(){return this.data.byteLength-4*this.offset4}}var L,ce;(function(n){n.SCALAR="SCALAR",n.VEC2="VEC2",n.VEC3="VEC3",n.VEC4="VEC4",n.MAT2="MAT2",n.MAT3="MAT3",n.MAT4="MAT4"})(L||(L={})),function(n){n[n.ARRAY_BUFFER=34962]="ARRAY_BUFFER",n[n.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(ce||(ce={}));const Ie={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1},Ut={pbrMetallicRoughness:Ie,emissiveFactor:[0,0,0],alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1},Ct={ESRI_externalColorMixMode:"tint"},de=(n={})=>{const e=h(h({},Ie),n.pbrMetallicRoughness),t=Rt(h(h({},Ct),n.extras));return se(h(h({},Ut),n),{pbrMetallicRoughness:e,extras:t})};function Rt(n){switch(n.ESRI_externalColorMixMode){case"multiply":case"tint":case"ignore":case"replace":break;default:he(n.ESRI_externalColorMixMode),n.ESRI_externalColorMixMode="tint"}return n}const Bt={magFilter:Q.LINEAR,minFilter:Q.LINEAR_MIPMAP_LINEAR,wrapS:K.REPEAT,wrapT:K.REPEAT},Mt=n=>h(h({},Bt),n);function $t(n){let e,t;return n.replace(/^(.*\/)?([^/]*)$/,(o,r,s)=>(e=r||"",t=s||"","")),{dirPart:e,filePart:t}}const V={MAGIC:1179937895,CHUNK_TYPE_JSON:1313821514,CHUNK_TYPE_BIN:5130562,MIN_HEADER_LENGTH:20};class I{constructor(e,t,o,r,s){this.context=e,this.errorContext=t,this.uri=o,this.json=r,this.glbBuffer=s,this.bufferLoaders=new Map,this.textureLoaders=new Map,this.textureCache=new Map,this.materialCache=new Map,this.nodeParentMap=new Map,this.nodeTransformCache=new Map,this.baseUri=$t(this.uri).dirPart,this._checkVersionSupported(),this._checkRequiredExtensionsSupported(),t.errorUnsupportedIf(r.scenes==null,"Scenes must be defined."),t.errorUnsupportedIf(r.meshes==null,"Meshes must be defined"),t.errorUnsupportedIf(r.nodes==null,"Nodes must be defined."),this._computeNodeParents()}static async load(e,t,o,r){if(pe(o)){const c=Ge(o);if(c.mediaType!=="model/gltf-binary")try{const i=JSON.parse(c.isBase64?atob(c.data):c.data);return new I(e,t,o,i)}catch{}const u=ye(o);if(I._isGLBData(u))return this._fromGLBData(e,t,o,u)}if(o.endsWith(".gltf")){const c=await e.loadJSON(o,r);return new I(e,t,o,c)}const s=await e.loadBinary(o,r);if(I._isGLBData(s))return this._fromGLBData(e,t,o,s);const a=await e.loadJSON(o,r);return new I(e,t,o,a)}static _isGLBData(e){const t=new ue(e);return t.remainingBytes()>=4&&t.readUint32()===V.MAGIC}static async _fromGLBData(e,t,o,r){const s=await I._parseGLBData(t,r);return new I(e,t,o,s.json,s.binaryData)}static async _parseGLBData(e,t){const o=new ue(t);e.assert(o.remainingBytes()>=12,"GLB binary data is insufficiently large.");const r=o.readUint32(),s=o.readUint32(),a=o.readUint32();e.assert(r===V.MAGIC,"Magic first 4 bytes do not fit to expected GLB value."),e.assert(t.byteLength>=a,"GLB binary data is smaller than header specifies."),e.errorUnsupportedIf(s!==2,"An unsupported GLB container version was detected. Only version 2 is supported.");let c,u,i=0;for(;o.remainingBytes()>=8;){const d=o.readUint32(),f=o.readUint32();i===0?(e.assert(f===V.CHUNK_TYPE_JSON,"First GLB chunk must be JSON."),e.assert(d>=0,"No JSON data found."),c=await Gt(o.readUint8Array(d))):i===1?(e.errorUnsupportedIf(f!==V.CHUNK_TYPE_BIN,"Second GLB chunk expected to be BIN."),u=o.readUint8Array(d)):e.warnUnsupported("More than 2 GLB chunks detected. Skipping."),i+=1}return c||e.error("No GLB JSON chunk detected."),{json:c,binaryData:u}}async getBuffer(e,t){const o=this.json.buffers[e],r=this.errorContext;if(o.uri==null)return r.assert(this.glbBuffer!=null,"GLB buffer not present"),this.glbBuffer;const s=await this._getBufferLoader(e,t);return r.assert(s.byteLength===o.byteLength,"Buffer byte lengths should match."),s}async _getBufferLoader(e,t){const o=this.bufferLoaders.get(e);if(o)return o;const r=this.json.buffers[e],s=this.context.loadBinary(this._resolveUri(r.uri),t).then(a=>new Uint8Array(a));return this.bufferLoaders.set(e,s),s}async getAccessor(e,t){const o=this.errorContext;o.errorUnsupportedIf(!this.json.accessors,"Accessors missing.");const r=this.json.accessors[e];o.errorUnsupportedIf((r==null?void 0:r.bufferView)==null,"Some accessor does not specify a bufferView."),o.errorUnsupportedIf(r.type in[L.MAT2,L.MAT3,L.MAT4],`AttributeType ${r.type} is not supported`);const s=this.json.bufferViews[r.bufferView],a=await this.getBuffer(s.buffer,t),c=Ft[r.type],u=Pt[r.componentType],i=c*u,d=s.byteStride||i;return{raw:a.buffer,byteStride:d,byteOffset:a.byteOffset+(s.byteOffset||0)+(r.byteOffset||0),entryCount:r.count,isDenselyPacked:d===i,componentCount:c,componentByteSize:u,componentType:r.componentType,min:r.min,max:r.max,normalized:!!r.normalized}}async getIndexData(e,t){if(e.indices==null)return null;const o=await this.getAccessor(e.indices,t);if(o.isDenselyPacked)switch(o.componentType){case l.UNSIGNED_BYTE:return new Uint8Array(o.raw,o.byteOffset,o.entryCount);case l.UNSIGNED_SHORT:return new Uint16Array(o.raw,o.byteOffset,o.entryCount);case l.UNSIGNED_INT:return new Uint32Array(o.raw,o.byteOffset,o.entryCount)}else switch(o.componentType){case l.UNSIGNED_BYTE:return J(this._wrapAccessor(tt,o));case l.UNSIGNED_SHORT:return J(this._wrapAccessor(et,o));case l.UNSIGNED_INT:return J(this._wrapAccessor(Ze,o))}}async getPositionData(e,t){const o=this.errorContext;o.errorUnsupportedIf(e.attributes.POSITION==null,"No POSITION vertex data found.");const r=await this.getAccessor(e.attributes.POSITION,t);return o.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for POSITION vertex attribute, but found "+Y[r.componentType]),o.errorUnsupportedIf(r.componentCount!==3,"POSITION vertex attribute must have 3 components, but found "+r.componentCount.toFixed()),this._wrapAccessor(Z,r)}async getNormalData(e,t){const o=this.errorContext;o.assert(e.attributes.NORMAL!=null,"No NORMAL vertex data found.");const r=await this.getAccessor(e.attributes.NORMAL,t);return o.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for NORMAL vertex attribute, but found "+Y[r.componentType]),o.errorUnsupportedIf(r.componentCount!==3,"NORMAL vertex attribute must have 3 components, but found "+r.componentCount.toFixed()),this._wrapAccessor(Z,r)}async getTangentData(e,t){const o=this.errorContext;o.assert(e.attributes.TANGENT!=null,"No TANGENT vertex data found.");const r=await this.getAccessor(e.attributes.TANGENT,t);return o.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for TANGENT vertex attribute, but found "+Y[r.componentType]),o.errorUnsupportedIf(r.componentCount!==4,"TANGENT vertex attribute must have 4 components, but found "+r.componentCount.toFixed()),new ie(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount)}async getTextureCoordinates(e,t){const o=this.errorContext;o.assert(e.attributes.TEXCOORD_0!=null,"No TEXCOORD_0 vertex data found.");const r=await this.getAccessor(e.attributes.TEXCOORD_0,t);return o.errorUnsupportedIf(r.componentCount!==2,"TEXCOORD_0 vertex attribute must have 2 components, but found "+r.componentCount.toFixed()),r.componentType===l.FLOAT?this._wrapAccessor(we,r):(o.errorUnsupportedIf(!r.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0."),Dt(r))}async getVertexColors(e,t){const o=this.errorContext;o.assert(e.attributes.COLOR_0!=null,"No COLOR_0 vertex data found.");const r=await this.getAccessor(e.attributes.COLOR_0,t);if(o.errorUnsupportedIf(r.componentCount!==4&&r.componentCount!==3,"COLOR_0 attribute must have 3 or 4 components, but found "+r.componentCount.toFixed()),r.componentCount===4){if(r.componentType===l.FLOAT)return this._wrapAccessor(ie,r);if(r.componentType===l.UNSIGNED_BYTE)return this._wrapAccessor(rt,r);if(r.componentType===l.UNSIGNED_SHORT)return this._wrapAccessor(nt,r)}else if(r.componentCount===3){if(r.componentType===l.FLOAT)return this._wrapAccessor(Z,r);if(r.componentType===l.UNSIGNED_BYTE)return this._wrapAccessor(ot,r);if(r.componentType===l.UNSIGNED_SHORT)return this._wrapAccessor(st,r)}o.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+Y[r.componentType])}hasPositions(e){return e.attributes.POSITION!==void 0}hasNormals(e){return e.attributes.NORMAL!==void 0}hasVertexColors(e){return e.attributes.COLOR_0!==void 0}hasTextureCoordinates(e){return e.attributes.TEXCOORD_0!==void 0}hasTangents(e){return e.attributes.TANGENT!==void 0}async getMaterial(e,t,o){let r=this.materialCache.get(e.material);if(!r){const s=e.material!=null?de(this.json.materials[e.material]):de(),a=s.pbrMetallicRoughness,c=this.hasVertexColors(e),u=this.getTexture(a.baseColorTexture,t),i=this.getTexture(s.normalTexture,t),d=o?this.getTexture(s.occlusionTexture,t):null,f=o?this.getTexture(s.emissiveTexture,t):null,p=o?this.getTexture(a.metallicRoughnessTexture,t):null,y=e.material!=null?e.material:-1;r={alphaMode:s.alphaMode,alphaCutoff:s.alphaCutoff,color:a.baseColorFactor,doubleSided:!!s.doubleSided,colorTexture:await u,normalTexture:await i,name:s.name,id:y,occlusionTexture:await d,emissiveTexture:await f,emissiveFactor:s.emissiveFactor,metallicFactor:a.metallicFactor,roughnessFactor:a.roughnessFactor,metallicRoughnessTexture:await p,hasVertexColors:c,ESRI_externalColorMixMode:s.extras.ESRI_externalColorMixMode}}return r}async getTexture(e,t){if(!e)return null;this.errorContext.errorUnsupportedIf((e.texCoord||0)!==0,"Only TEXCOORD with index 0 is supported.");const o=e.index,r=this.errorContext,s=this.json.textures[o],a=Mt(s.sampler!=null?this.json.samplers[s.sampler]:{});r.errorUnsupportedIf(s.source==null,"Source is expected to be defined for a texture.");const c=this.json.images[s.source],u=await this._loadTextureImageData(o,s,t);return je(this.textureCache,o,()=>{const i=f=>f===33071||f===33648||f===10497,d=f=>(r.error(`Unexpected TextureSampler WrapMode: ${f}. Using default REPEAT(10497).`),10497);return{data:u,wrapS:i(a.wrapS)?a.wrapS:d(a.wrapS),wrapT:i(a.wrapT)?a.wrapT:d(a.wrapT),minFilter:a.minFilter,name:c.name,id:o}})}getNodeTransform(e){if(e===void 0)return vt;let t=this.nodeTransformCache.get(e);if(!t){const o=this.getNodeTransform(this._getNodeParent(e)),r=this.json.nodes[e];r.matrix?t=Ve(be(),o,r.matrix):r.translation||r.rotation||r.scale?(t=xe(o),r.translation&&ke(t,t,r.translation),r.rotation&&(k[3]=Qe(k,r.rotation),Ye(t,t,k[3],k)),r.scale&&qe(t,t,r.scale)):t=o,this.nodeTransformCache.set(e,t)}return t}_wrapAccessor(e,t){return new e(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*(t.entryCount-1)+t.componentByteSize*t.componentCount)}_resolveUri(e){return ze(e,this.baseUri)}_getNodeParent(e){return this.nodeParentMap.get(e)}_checkVersionSupported(){const e=Te.parse(this.json.asset.version,"glTF");Lt.validate(e)}_checkRequiredExtensionsSupported(){const e=this.json,t=this.errorContext;e.extensionsRequired&&e.extensionsRequired.length!==0&&t.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+e.extensionsRequired.join(", "))}_computeNodeParents(){this.json.nodes.forEach((e,t)=>{e.children&&e.children.forEach(o=>{this.nodeParentMap.set(o,t)})})}async _loadTextureImageData(e,t,o){const r=this.textureLoaders.get(e);if(r)return r;const s=this._createTextureLoader(t,o);return this.textureLoaders.set(e,s),s}async _createTextureLoader(e,t){const o=this.json.images[e.source];if(o.uri)return this.context.loadImage(this._resolveUri(o.uri),t);const r=this.errorContext;r.errorUnsupportedIf(o.bufferView==null,"Image bufferView must be defined."),r.errorUnsupportedIf(o.mimeType==null,"Image mimeType must be defined.");const s=this.json.bufferViews[o.bufferView],a=await this.getBuffer(s.buffer,t);return r.errorUnsupportedIf(s.byteStride!=null,"byteStride not supported for image buffer"),jt(new Uint8Array(a.buffer,a.byteOffset+(s.byteOffset||0),s.byteLength),o.mimeType)}}const Lt=new Te(2,0,"glTF"),vt=De(be(),Math.PI/2),k=We(),Ft={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},Pt={[l.BYTE]:1,[l.UNSIGNED_BYTE]:1,[l.SHORT]:2,[l.UNSIGNED_SHORT]:2,[l.FLOAT]:4,[l.UNSIGNED_INT]:4};function Dt(n){switch(n.componentType){case l.BYTE:return new dt(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);case l.UNSIGNED_BYTE:return new ct(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);case l.SHORT:return new ut(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);case l.UNSIGNED_SHORT:return new it(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);case l.UNSIGNED_INT:return new at(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);case l.FLOAT:return new we(n.raw,n.byteOffset,n.byteStride,n.byteOffset+n.byteStride*n.entryCount);default:return void he(n.componentType)}}async function Gt(n){return new Promise((e,t)=>{const o=new Blob([n]),r=new FileReader;r.onload=()=>{const s=r.result;e(JSON.parse(s))},r.onerror=s=>{t(s)},r.readAsText(o)})}async function jt(n,e){return new Promise((t,o)=>{const r=new Blob([n],{type:e}),s=URL.createObjectURL(r),a=new Image;a.addEventListener("load",()=>{URL.revokeObjectURL(s),"decode"in a?a.decode().then(()=>t(a),()=>t(a)):t(a)}),a.addEventListener("error",c=>{URL.revokeObjectURL(s),o(c)}),a.src=s})}const Y={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"};let Vt=0;async function dr(n,e,t={},o=!0){const r=await I.load(n,X,e,t),s="gltf_"+Vt++,a={lods:[],materials:new Map,textures:new Map,meta:kt(r)},c=!(!r.json.asset.extras||r.json.asset.extras.ESRI_type!=="symbolResource"),u=new Map;await Yt(r,async(i,d,f,p)=>{var U;const y=(U=u.get(f))!=null?U:0;u.set(f,y+1);const m=i.mode!==void 0?i.mode:j.TRIANGLES,w=m===j.TRIANGLES||m===j.TRIANGLE_STRIP||m===j.TRIANGLE_FAN?m:null;if(me(w))return void X.warnUnsupported("Unsupported primitive mode ("+Jt[m]+"). Skipping primitive.");if(!r.hasPositions(i))return void X.warn("Skipping primitive without POSITION vertex attribute.");const M=r.getPositionData(i,t),_=r.getMaterial(i,t,o),S=r.hasNormals(i)?r.getNormalData(i,t):null,g=r.hasTangents(i)?r.getTangentData(i,t):null,T=r.hasTextureCoordinates(i)?r.getTextureCoordinates(i,t):null,E=r.hasVertexColors(i)?r.getVertexColors(i,t):null,b=r.getIndexData(i,t),$={transform:xe(d),attributes:{position:await M,normal:S?await S:null,texCoord0:T?await T:null,color:E?await E:null,tangent:g?await g:null},indices:await b,primitiveType:w,material:zt(a,await _,s)};let A=null;re(a.meta)&&re(a.meta.ESRI_lod)&&a.meta.ESRI_lod.metric==="screenSpaceRadius"&&(A=a.meta.ESRI_lod.thresholds[f]),a.lods[f]=a.lods[f]||{parts:[],name:p,lodThreshold:A},a.lods[f].parts[y]=$});for(const i of a.lods)i.parts=i.parts.filter(d=>!!d);return{model:a,meta:{isEsriSymbolResource:c,uri:r.uri},customMeta:{}}}function kt(n){const e=n.json;let t=null;return e.nodes.forEach(o=>{const r=o.extras;re(r)&&(r.ESRI_proxyEllipsoid||r.ESRI_lod)&&(t=r)}),t}async function Yt(n,e){const t=n.json,o=t.scenes[t.scene||0].nodes,r=o.length>1,s=[];for(const c of o){const u=t.nodes[c];s.push(a(c,0)),qt(u)&&!r&&u.extensions.MSFT_lod.ids.forEach((i,d)=>a(i,d+1))}async function a(c,u){const i=t.nodes[c],d=n.getNodeTransform(c);if(X.warnUnsupportedIf(i.weights!=null,"Morph targets are not supported."),i.mesh!=null){const f=t.meshes[i.mesh];for(const p of f.primitives)s.push(e(p,d,u,f.name))}for(const f of i.children||[])s.push(a(f,u))}await Promise.all(s)}function qt(n){return n.extensions&&n.extensions.MSFT_lod&&Array.isArray(n.extensions.MSFT_lod.ids)}function zt(n,e,t){const o=s=>{const a=`${t}_tex_${s&&s.id}${s&&s.name?"_"+s.name:""}`;if(s&&!n.textures.has(a)){const c=At(s.data,{wrap:{s:s.wrapS,t:s.wrapT},mipmap:Ht.includes(s.minFilter),noUnpackFlip:!0});n.textures.set(a,c)}return a},r=`${t}_mat_${e.id}_${e.name}`;if(!n.materials.has(r)){const s=Nt({color:[e.color[0],e.color[1],e.color[2]],opacity:e.color[3],alphaMode:e.alphaMode,alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,colorMixMode:e.ESRI_externalColorMixMode,textureColor:e.colorTexture?o(e.colorTexture):void 0,textureNormal:e.normalTexture?o(e.normalTexture):void 0,textureOcclusion:e.occlusionTexture?o(e.occlusionTexture):void 0,textureEmissive:e.emissiveTexture?o(e.emissiveTexture):void 0,textureMetallicRoughness:e.metallicRoughnessTexture?o(e.metallicRoughnessTexture):void 0,emissiveFactor:[e.emissiveFactor[0],e.emissiveFactor[1],e.emissiveFactor[2]],metallicFactor:e.metallicFactor,roughnessFactor:e.roughnessFactor});n.materials.set(r,s)}return r}const X=new Ot,Ht=[Q.LINEAR_MIPMAP_LINEAR,Q.LINEAR_MIPMAP_NEAREST],Jt=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function Xt(n,e,t){return ae(ee,e,n),ae(fe,t,n),He(Je(ee,ee,fe))/2}new Se(ft);new Se(()=>({p0:null,p1:null,p2:null}));const ee=B(),fe=B();let N=(()=>{const n=new Uint32Array(131072);for(let e=0;e<n.length;++e)n[e]=e;return n})();const _e=new Uint16Array([0]),W=(()=>{const n=new Uint16Array(65536);for(let e=0;e<n.length;++e)n[e]=e;return n})();function Kt(n){if(n===1)return _e;if(n<W.length)return new Uint16Array(W.buffer,0,n);if(n>N.length){const e=Math.max(2*N.length,n);N=new Uint32Array(e);for(let t=0;t<N.length;t++)N[t]=t}return new Uint32Array(N.buffer,0,n)}function fr(n){if(n===1)return new Uint16Array(_e);if(n<W.length)return new Uint16Array(W.slice(0,n));if(n>N.length){const e=new Uint32Array(n);for(let t=0;t<e.length;t++)e[t]=t;return e}return new Uint32Array(N.slice(0,n))}function lr(n,e,t){if(!n)return!1;const{size:o,data:r}=n;R(t,0,0,0),R(O,0,0,0);let s=0,a=0;for(let c=0;c<e.length-2;c+=3){const u=e[c+0]*o,i=e[c+1]*o,d=e[c+2]*o;R(x,r[u+0],r[u+1],r[u+2]),R(q,r[i+0],r[i+1],r[i+2]),R(z,r[d+0],r[d+1],r[d+2]);const f=Xt(x,q,z);f?(C(x,x,q),C(x,x,z),H(x,x,1/3*f),C(t,t,x),s+=f):(C(O,O,x),C(O,O,q),C(O,O,z),a+=3)}return(a!==0||s!==0)&&(s!==0?(H(t,t,1/s),!0):a!==0&&(H(t,O,1/a),!0))}function pr(n,e,t){if(!n||!e)return!1;const{size:o,data:r}=n;R(t,0,0,0);let s=-1,a=0;for(let c=0;c<e.length;c++){const u=e[c]*o;s!==u&&(t[0]+=r[u+0],t[1]+=r[u+1],t[2]+=r[u+2],a++),s=u}return a>1&&H(t,t,1/a),a>0}const x=B(),q=B(),z=B(),O=B();function yr(n,e=Kt){return typeof n=="number"?e(n):Xe(n)||Ke(n)?new Uint32Array(n):n}function mr(n){const e=typeof n=="number"?n:n.length;if(e<3)return new Uint16Array(0);const t=e-2,o=t<=65536?new Uint16Array(3*t):new Uint32Array(3*t);if(typeof n=="number"){let r=0;for(let s=0;s<t;s+=1)s%2==0?(o[r++]=s,o[r++]=s+1,o[r++]=s+2):(o[r++]=s+1,o[r++]=s,o[r++]=s+2)}else{let r=0;for(let s=0;s<t;s+=1)if(s%2==0){const a=n[s],c=n[s+1],u=n[s+2];o[r++]=a,o[r++]=c,o[r++]=u}else{const a=n[s+1],c=n[s],u=n[s+2];o[r++]=a,o[r++]=c,o[r++]=u}}return o}function hr(n){const e=typeof n=="number"?n:n.length;if(e<3)return new Uint16Array(0);const t=e-2,o=t<=65536?new Uint16Array(3*t):new Uint32Array(3*t);if(typeof n=="number"){let r=0;for(let s=0;s<t;++s)o[r++]=0,o[r++]=s+1,o[r++]=s+2;return o}{const r=n[0];let s=n[1],a=0;for(let c=0;c<t;++c){const u=n[c+2];o[a++]=r,o[a++]=s,o[a++]=u,s=u}return o}}const Tr=2.1;export{pt as a,wt as b,dr as c,mt as d,gt as e,mr as f,pr as g,yr as h,hr as i,yt as j,St as k,Kt as l,ht as m,cr as n,Tr as o,fr as p,ur as r,It as t,lr as u};
