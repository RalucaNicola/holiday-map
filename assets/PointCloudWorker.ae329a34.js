var q=Object.defineProperty,G=Object.defineProperties;var W=Object.getOwnPropertyDescriptors;var V=Object.getOwnPropertySymbols;var K=Object.prototype.hasOwnProperty,Q=Object.prototype.propertyIsEnumerable;var E=(t,e,r)=>e in t?q(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,M=(t,e)=>{for(var r in e||(e={}))K.call(e,r)&&E(t,r,e[r]);if(V)for(var r of V(e))Q.call(e,r)&&E(t,r,e[r]);return t},F=(t,e)=>G(t,W(e));import{C as y,s as ee,bf as te,r as v,w as re,i3 as ne,b4 as Y,g_ as oe,i4 as ie}from"./vendor.c414a8c9.js";import{S as ae}from"./quat.b252f462.js";import{r as se,n as R}from"./vec3f32.8d37ecf5.js";import{a as ce,b as ue,d as le}from"./PointCloudUniqueValueRenderer.6691b16d.js";import{O as A}from"./VertexAttribute.5551e0d8.js";import"./quatf64.ddec7ef6.js";function H(){const t=new Float32Array(4);return t[3]=1,t}function fe(t){const e=new Float32Array(4);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function de(t,e,r,i){const s=new Float32Array(4);return s[0]=t,s[1]=e,s[2]=r,s[3]=i,s}function be(t,e){return new Float32Array(t,e,4)}Object.freeze(Object.defineProperty({__proto__:null,create:H,clone:fe,fromValues:de,createView:be},Symbol.toStringTag,{value:"Module"}));const g=!0,U={identifierOffset:0,identifierLength:10,versionOffset:10,checksumOffset:12,byteCount:16};function D(t,e,r){return{identifier:String.fromCharCode.apply(null,new Uint8Array(t,r+U.identifierOffset,U.identifierLength)),version:e.getUint16(r+U.versionOffset,g),checksum:e.getUint32(r+U.checksumOffset,g)}}const h={sizeLo:0,sizeHi:4,minX:8,minY:16,minZ:24,maxX:32,maxY:40,maxZ:48,errorX:56,errorY:64,errorZ:72,count:80,reserved:84,byteCount:88};function ye(t,e){return{sizeLo:t.getUint32(e+h.sizeLo,g),sizeHi:t.getUint32(e+h.sizeHi,g),minX:t.getFloat64(e+h.minX,g),minY:t.getFloat64(e+h.minY,g),minZ:t.getFloat64(e+h.minZ,g),maxX:t.getFloat64(e+h.maxX,g),maxY:t.getFloat64(e+h.maxY,g),maxZ:t.getFloat64(e+h.maxZ,g),errorX:t.getFloat64(e+h.errorX,g),errorY:t.getFloat64(e+h.errorY,g),errorZ:t.getFloat64(e+h.errorZ,g),count:t.getUint32(e+h.count,g),reserved:t.getUint32(e+h.reserved,g)}}function ge(t){const e=new DataView(t,0);let r=0;const{identifier:i,version:s}=D(t,e,r);if(r+=U.byteCount,i!=="LEPCC     ")throw new y("lepcc-decode-error","Bad identifier");if(s>1)throw new y("lepcc-decode-error","Unknown version");const n=ye(e,r);if(r+=h.byteCount,n.sizeHi*2**32+n.sizeLo!==t.byteLength)throw new y("lepcc-decode-error","Bad size");const a=new Float64Array(3*n.count),u=[],o=[],l=[],c=[];if(r=z(t,r,u),r=z(t,r,o),r=z(t,r,l),r=z(t,r,c),r!==t.byteLength)throw new y("lepcc-decode-error","Bad length");let f=0,d=0;for(let b=0;b<u.length;b++){d+=u[b];let p=0;for(let w=0;w<o[b];w++){p+=l[f];const I=c[f];a[3*f]=Math.min(n.maxX,n.minX+2*n.errorX*p),a[3*f+1]=Math.min(n.maxY,n.minY+2*n.errorY*d),a[3*f+2]=Math.min(n.maxZ,n.minZ+2*n.errorZ*I),f++}}return{errorX:n.errorX,errorY:n.errorY,errorZ:n.errorZ,result:a}}function z(t,e,r){const i=[];e=T(t,e,i);const s=[];for(let n=0;n<i.length;n++){s.length=0,e=T(t,e,s);for(let a=0;a<s.length;a++)r.push(s[a]+i[n])}return e}function T(t,e,r){const i=new DataView(t,e),s=i.getUint8(0),n=31&s,a=!!(32&s),u=(192&s)>>6;let o=0;if(u===0)o=i.getUint32(1,g),e+=5;else if(u===1)o=i.getUint16(1,g),e+=3;else{if(u!==2)throw new y("lepcc-decode-error","Bad count type");o=i.getUint8(1),e+=2}if(a)throw new y("lepcc-decode-error","LUT not implemented");const l=Math.ceil(o*n/8),c=new Uint8Array(t,e,l);let f=0,d=0,b=0;const p=-1>>>32-n;for(let w=0;w<o;w++){for(;d<n;)f|=c[b]<<d,d+=8,b+=1;r[w]=f&p,f>>>=n,d-=n,d+n>32&&(f|=c[b-1]>>8-d)}return e+b}const m={sizeLo:0,sizeHi:4,count:8,colorMapCount:12,lookupMethod:14,compressionMethod:15,byteCount:16};function pe(t,e){return{sizeLo:t.getUint32(e+m.sizeLo,g),sizeHi:t.getUint32(e+m.sizeHi,g),count:t.getUint32(e+m.count,g),colorMapCount:t.getUint16(e+m.colorMapCount,g),lookupMethod:t.getUint8(e+m.lookupMethod),compressionMethod:t.getUint8(e+m.compressionMethod)}}function he(t){const e=new DataView(t,0);let r=0;const{identifier:i,version:s}=D(t,e,r);if(r+=U.byteCount,i!=="ClusterRGB")throw new y("lepcc-decode-error","Bad identifier");if(s>1)throw new y("lepcc-decode-error","Unknown version");const n=pe(e,r);if(r+=m.byteCount,n.sizeHi*2**32+n.sizeLo!==t.byteLength)throw new y("lepcc-decode-error","Bad size");if((n.lookupMethod===2||n.lookupMethod===1)&&n.compressionMethod===0){if(3*n.colorMapCount+n.count+r!==t.byteLength||n.colorMapCount>256)throw new y("lepcc-decode-error","Bad count");const a=new Uint8Array(t,r,3*n.colorMapCount),u=new Uint8Array(t,r+3*n.colorMapCount,n.count),o=new Uint8Array(3*n.count);for(let l=0;l<n.count;l++){const c=u[l];o[3*l]=a[3*c],o[3*l+1]=a[3*c+1],o[3*l+2]=a[3*c+2]}return o}if(n.lookupMethod===0&&n.compressionMethod===0){if(3*n.count+r!==t.byteLength||n.colorMapCount!==0)throw new y("lepcc-decode-error","Bad count");return new Uint8Array(t,r).slice()}if(n.lookupMethod<=2&&n.compressionMethod===1){if(r+3!==t.byteLength||n.colorMapCount!==1)throw new y("lepcc-decode-error","Bad count");const a=e.getUint8(r),u=e.getUint8(r+1),o=e.getUint8(r+2),l=new Uint8Array(3*n.count);for(let c=0;c<n.count;c++)l[3*c]=a,l[3*c+1]=u,l[3*c+2]=o;return l}throw new y("lepcc-decode-error","Bad method "+n.lookupMethod+","+n.compressionMethod)}const C={sizeLo:0,sizeHi:4,count:8,scaleFactor:12,bitsPerPoint:14,reserved:15,byteCount:16};function we(t,e){return{sizeLo:t.getUint32(e+C.sizeLo,g),sizeHi:t.getUint32(e+C.sizeHi,g),count:t.getUint32(e+C.count,g),scaleFactor:t.getUint16(e+C.scaleFactor,g),bitsPerPoint:t.getUint8(e+C.bitsPerPoint),reserved:t.getUint8(e+C.reserved)}}function me(t){const e=new DataView(t,0);let r=0;const{identifier:i,version:s}=D(t,e,r);if(r+=U.byteCount,i!=="Intensity ")throw new y("lepcc-decode-error","Bad identifier");if(s>1)throw new y("lepcc-decode-error","Unknown version");const n=we(e,r);if(r+=C.byteCount,n.sizeHi*2**32+n.sizeLo!==t.byteLength)throw new y("lepcc-decode-error","Bad size");const a=new Uint16Array(n.count);if(n.bitsPerPoint===8){if(n.count+r!==t.byteLength)throw new y("lepcc-decode-error","Bad size");const u=new Uint8Array(t,r,n.count);for(let o=0;o<n.count;o++)a[o]=u[o]*n.scaleFactor}else if(n.bitsPerPoint===16){if(2*n.count+r!==t.byteLength)throw new y("lepcc-decode-error","Bad size");const u=new Uint16Array(t,r,n.count);for(let o=0;o<n.count;o++)a[o]=u[o]*n.scaleFactor}else{const u=[];if(T(t,r,u)!==t.byteLength)throw new y("lepcc-decode-error","Bad size");for(let o=0;o<n.count;o++)a[o]=u[o]*n.scaleFactor}return a}const x=ee.getLogger("esri.views.3d.layers.i3s.I3SBinaryReader");function Ce(t,e,r){let i="",s=0;for(;s<r;){const n=t[e+s];if(n<128)i+=String.fromCharCode(n),s++;else if(n>=192&&n<224){if(s+1>=r)throw new y("utf8-decode-error","UTF-8 Decode failed. Two byte character was truncated.");const a=(31&n)<<6|63&t[e+s+1];i+=String.fromCharCode(a),s+=2}else if(n>=224&&n<240){if(s+2>=r)throw new y("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const a=(15&n)<<12|(63&t[e+s+1])<<6|63&t[e+s+2];i+=String.fromCharCode(a),s+=3}else{if(!(n>=240&&n<248))throw new y("utf8-decode-error","UTF-8 Decode failed. Invalid multi byte sequence.");{if(s+3>=r)throw new y("utf8-decode-error","UTF-8 Decode failed. Multi byte character was truncated.");const a=(7&n)<<18|(63&t[e+s+1])<<12|(63&t[e+s+2])<<6|63&t[e+s+3];if(a>=65536){const u=55296+(a-65536>>10),o=56320+(1023&a);i+=String.fromCharCode(u,o)}else i+=String.fromCharCode(a);s+=4}}}return i}function N(t,e){const r={byteOffset:0,byteCount:0,fields:Object.create(null)};let i=0;for(let s=0;s<e.length;s++){const n=e[s],a=n.valueType||n.type,u=Me[a];r.fields[n.property]=u(t,i),i+=B[a].BYTES_PER_ELEMENT}return r.byteCount=i,r}function Ue(t,e,r){const i=[];let s,n,a=0;for(n=0;n<t;n+=1){if(s=e[n],s>0){if(i.push(Ce(r,a,s-1)),r[a+s-1]!==0)throw new y("string-array-error","Invalid string array: missing null termination.")}else i.push(null);a+=s}return i}function k(t,e){return new B[e.valueType](t,e.byteOffset,e.count*e.valuesPerElement)}function ve(t,e){return new Uint8Array(t,e.byteOffset,e.byteCount)}function Ae(t,e,r){const i=e.header!=null?N(t,e.header):{byteOffset:0,byteCount:0,fields:{count:r}},s={header:i,byteOffset:i.byteCount,byteCount:0,entries:Object.create(null)};let n=i.byteCount;for(let a=0;a<e.ordering.length;a++){const u=e.ordering[a],o=te(e[u]);if(o.count=i.fields.count,o.valueType==="String"){if(o.byteOffset=n,o.byteCount=i.fields[u+"ByteCount"],o.encoding!=="UTF-8")throw new y("unsupported-encoding","Unsupported String encoding.",{encoding:o.encoding})}else{if(!J(o.valueType))throw new y("unsupported-value-type","Unsupported binary valueType",{valueType:o.valueType});{const l=$(o.valueType);n+=n%l!=0?l-n%l:0,o.byteOffset=n,o.byteCount=l*o.valuesPerElement*o.count}}n+=o.byteCount,s.entries[u]=o}return s.byteCount=n-s.byteOffset,s}function j(t,e,r){if(e!==t&&x.error(`Invalid ${r} buffer size
 expected: ${t}, actual: ${e})`),e<t)throw new y("buffer-too-small","Binary buffer is too small",{expectedSize:t,actualSize:e})}function Ie(t,e){const r=N(t,e&&e.header);let i=r.byteCount;const s={isDraco:!1,header:r,byteOffset:r.byteCount,byteCount:0,vertexAttributes:{}},n=r.fields,a=n.vertexCount!=null?n.vertexCount:n.count;for(const l of e.ordering){if(!e.vertexAttributes[l])continue;const c=F(M({},e.vertexAttributes[l]),{byteOffset:i,count:a}),f=X[l]?X[l]:"_"+l;s.vertexAttributes[f]=c,i+=$(c.valueType)*c.valuesPerElement*a}const u=n.faceCount;if(e.faces&&u){s.faces={};for(const l of e.ordering){if(!e.faces[l])continue;const c=F(M({},e.faces[l]),{byteOffset:i,count:u});s.faces[l]=c,i+=$(c.valueType)*c.valuesPerElement*u}}const o=n.featureCount;if(e.featureAttributes&&e.featureAttributeOrder&&o){s.featureAttributes={};for(const l of e.featureAttributeOrder){if(!e.featureAttributes[l])continue;const c=F(M({},e.featureAttributes[l]),{byteOffset:i,count:o});s.featureAttributes[l]=c,i+=(c.valueType==="UInt64"?8:$(c.valueType))*c.valuesPerElement*o}}return j(i,t.byteLength,"geometry"),s.byteCount=i-s.byteOffset,s}const X={position:A.POSITION,normal:A.NORMAL,color:A.COLOR,uv0:A.UV0,region:A.UVREGION};function Oe(t,e,r){if(t.encoding==="lepcc-rgb")return he(e);if(t.encoding==="lepcc-intensity")return me(e);if(t.encoding!=null&&t.encoding!=="")throw new y("unknown-attribute-storage-info-encoding","Unknown Attribute Storage Info Encoding");t["attributeByteCounts "]&&!t.attributeByteCounts&&(x.warn("Warning: Trailing space in 'attributeByteCounts '."),t.attributeByteCounts=t["attributeByteCounts "]),t.ordering[0]==="ObjectIds"&&t.hasOwnProperty("objectIds")&&(x.warn("Warning: Case error in objectIds"),t.ordering[0]="objectIds");const i=Ae(e,t,r);j(i.byteOffset+i.byteCount,e.byteLength,"attribute");const s=i.entries.attributeValues||i.entries.objectIds;if(s){if(s.valueType==="String"){const n=i.entries.attributeByteCounts,a=k(e,n),u=ve(e,s);return Ue(n.count,a,u)}return k(e,s)}throw new y("bad-attribute-storage-info","Bad attributeStorageInfo specification.")}const B={Float32:Float32Array,Float64:Float64Array,UInt8:Uint8Array,Int8:Int8Array,UInt16:Uint16Array,Int16:Int16Array,UInt32:Uint32Array,Int32:Int32Array},Me={Float32:(t,e)=>new DataView(t,0).getFloat32(e,!0),Float64:(t,e)=>new DataView(t,0).getFloat64(e,!0),UInt8:(t,e)=>new DataView(t,0).getUint8(e),Int8:(t,e)=>new DataView(t,0).getInt8(e),UInt16:(t,e)=>new DataView(t,0).getUint16(e,!0),Int16:(t,e)=>new DataView(t,0).getInt16(e,!0),UInt32:(t,e)=>new DataView(t,0).getUint32(e,!0),Int32:(t,e)=>new DataView(t,0).getInt32(e,!0)};function J(t){return B.hasOwnProperty(t)}function $(t){return J(t)?B[t].BYTES_PER_ELEMENT:0}function Fe(t,e,r,i){const{rendererJSON:s,isRGBRenderer:n}=t;let a=null,u=null;if(e&&n)a=e;else if(e&&s.type==="pointCloudUniqueValueRenderer"){u=ce.fromJSON(s);const o=u.colorUniqueValueInfos;a=new Uint8Array(3*i);const l=L(u.fieldTransformType);for(let c=0;c<i;c++){const f=(l?l(e[c]):e[c])+"";for(let d=0;d<o.length;d++)if(o[d].values.includes(f)){a[3*c]=o[d].color.r,a[3*c+1]=o[d].color.g,a[3*c+2]=o[d].color.b;break}}}else if(e&&s.type==="pointCloudStretchRenderer"){u=ue.fromJSON(s);const o=u.stops;a=new Uint8Array(3*i);const l=L(u.fieldTransformType);for(let c=0;c<i;c++){const f=l?l(e[c]):e[c],d=o.length-1;if(f<o[0].value)a[3*c]=o[0].color.r,a[3*c+1]=o[0].color.g,a[3*c+2]=o[0].color.b;else if(f>=o[d].value)a[3*c]=o[d].color.r,a[3*c+1]=o[d].color.g,a[3*c+2]=o[d].color.b;else for(let b=1;b<o.length;b++)if(f<o[b].value){const p=(f-o[b-1].value)/(o[b].value-o[b-1].value);a[3*c]=o[b].color.r*p+o[b-1].color.r*(1-p),a[3*c+1]=o[b].color.g*p+o[b-1].color.g*(1-p),a[3*c+2]=o[b].color.b*p+o[b-1].color.b*(1-p);break}}}else if(e&&s.type==="pointCloudClassBreaksRenderer"){u=le.fromJSON(s);const o=u.colorClassBreakInfos;a=new Uint8Array(3*i);const l=L(u.fieldTransformType);for(let c=0;c<i;c++){const f=l?l(e[c]):e[c];for(let d=0;d<o.length;d++)if(f>=o[d].minValue&&f<=o[d].maxValue){a[3*c]=o[d].color.r,a[3*c+1]=o[d].color.g,a[3*c+2]=o[d].color.b;break}}}else{a=new Uint8Array(3*i);for(let o=0;o<a.length;o++)a[o]=255}if(r&&u&&u.colorModulation){const o=u.colorModulation.minValue,l=u.colorModulation.maxValue,c=.3;for(let f=0;f<i;f++){const d=r[f],b=d>=l?1:d<=o?c:c+(1-c)*(d-o)/(l-o);a[3*f]=b*a[3*f],a[3*f+1]=b*a[3*f+1],a[3*f+2]=b*a[3*f+2]}}return a}function ze(t,e){if(t.encoding==null||t.encoding===""){const r=Ie(e,t);if(re(r.vertexAttributes.position))return;const i=k(e,r.vertexAttributes.position),s=r.header.fields,n=[s.offsetX,s.offsetY,s.offsetZ],a=[s.scaleX,s.scaleY,s.scaleZ],u=i.length/3,o=new Float64Array(3*u);for(let l=0;l<u;l++)o[3*l]=i[3*l]*a[0]+n[0],o[3*l+1]=i[3*l+1]*a[1]+n[1],o[3*l+2]=i[3*l+2]*a[2]+n[2];return o}if(t.encoding==="lepcc-xyz")return ge(e).result}function S(t,e,r){return v(t)&&t.attributeInfo.useElevation?Se(e,r):v(t)?Oe(t.attributeInfo.storageInfo,t.buffer,r):null}function Se(t,e){const r=new Float64Array(e);for(let i=0;i<e;i++)r[i]=t[3*i+2];return r}function $e(t,e,r,i,s){const n=t.length/3;let a=0;for(let u=0;u<n;u++){let o=!0;for(let l=0;l<i.length&&o;l++){const{filterJSON:c}=i[l],f=s[l].values[u];switch(c.type){case"pointCloudValueFilter":{const d=c.mode==="exclude";c.values.includes(f)===d&&(o=!1);break}case"pointCloudBitfieldFilter":{const d=Z(c.requiredSetBits),b=Z(c.requiredClearBits);(f&d)===d&&(f&b)==0||(o=!1);break}case"pointCloudReturnFilter":{const d=15&f,b=f>>>4&15,p=b>1,w=d===1,I=d===b;let P=!1;for(const O of c.includedReturns)if(O==="last"&&I||O==="firstOfMany"&&w&&p||O==="lastOfMany"&&I&&p||O==="single"&&!p){P=!0;break}P||(o=!1);break}}}o&&(r[a]=u,t[3*a]=t[3*u],t[3*a+1]=t[3*u+1],t[3*a+2]=t[3*u+2],e[3*a]=e[3*u],e[3*a+1]=e[3*u+1],e[3*a+2]=e[3*u+2],a++)}return a}function L(t){return t==null||t==="none"?null:t==="low-four-bit"?e=>15&e:t==="high-four-bit"?e=>(240&e)>>4:t==="absolute-value"?e=>Math.abs(e):t==="modulo-ten"?e=>e%10:null}function Z(t){let e=0;for(const r of t||[])e|=1<<r;return e}class Be{transform(e){const r=this._transform(e),i=[r.points.buffer,r.rgb.buffer];v(r.pointIdFilterMap)&&i.push(r.pointIdFilterMap.buffer);for(const s of r.attributes)"buffer"in s.values&&ne(s.values.buffer)&&s.values.buffer!==r.rgb.buffer&&i.push(s.values.buffer);return Promise.resolve({result:r,transferList:i})}_transform(e){const r=ze(e.schema,e.geometryBuffer);let i=r.length/3,s=null;const n=[],a=S(e.primaryAttributeData,r,i);v(e.primaryAttributeData)&&a&&n.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:a});const u=S(e.modulationAttributeData,r,i);v(e.modulationAttributeData)&&u&&n.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:u});let o=Fe(e.rendererInfo,a,u,i);if(e.filterInfo&&e.filterInfo.length>0&&v(e.filterAttributesData)){const c=e.filterAttributesData.map(f=>{const d=S(f,r,i),b={attributeInfo:f.attributeInfo,values:d};return n.push(b),b});s=new Uint32Array(i),i=$e(r,o,s,e.filterInfo,c)}for(const c of e.userAttributesData){const f=S(c,r,i);n.push({attributeInfo:c.attributeInfo,values:f})}3*i<o.length&&(o=new Uint8Array(o.buffer.slice(0,3*i))),this._applyElevationOffsetInPlace(r,i,e.elevationOffset);const l=this._transformCoordinates(r,i,e.obb,Y.fromJSON(e.inSR),Y.fromJSON(e.outSR));return{obb:e.obb,points:l,rgb:o,attributes:n,pointIdFilterMap:s}}_transformCoordinates(e,r,i,s,n){if(!oe(e,s,0,e,n,0,r))throw Error("Can't reproject");const a=se(i.center[0],i.center[1],i.center[2]),u=R(),o=R();ae(_,i.quaternion);const l=new Float32Array(3*r);for(let c=0;c<r;c++)u[0]=e[3*c]-a[0],u[1]=e[3*c+1]-a[1],u[2]=e[3*c+2]-a[2],ie(o,u,_),i.halfSize[0]=Math.max(i.halfSize[0],Math.abs(o[0])),i.halfSize[1]=Math.max(i.halfSize[1],Math.abs(o[1])),i.halfSize[2]=Math.max(i.halfSize[2],Math.abs(o[2])),l[3*c]=u[0],l[3*c+1]=u[1],l[3*c+2]=u[2];return l}_applyElevationOffsetInPlace(e,r,i){if(i!==0)for(let s=0;s<r;s++)e[3*s+2]+=i}}const _=H();function Ee(){return new Be}export{Ee as default};
