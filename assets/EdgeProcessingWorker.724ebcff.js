var vt=Object.defineProperty,Dt=Object.defineProperties;var Vt=Object.getOwnPropertyDescriptors;var it=Object.getOwnPropertySymbols;var Pt=Object.prototype.hasOwnProperty,xt=Object.prototype.propertyIsEnumerable;var at=(t,e,n)=>e in t?vt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,ct=(t,e)=>{for(var n in e||(e={}))Pt.call(e,n)&&at(t,n,e[n]);if(it)for(var n of it(e))xt.call(e,n)&&at(t,n,e[n]);return t},lt=(t,e)=>Dt(t,Vt(e));import{n as Mt}from"./deduplicate.092a1fcc.js";import{T as U}from"./InterleavedLayout.2c4bf260.js";import{y as bt,u as Ut,i as Ft,c as Rt,l as Bt,p as Ct,o as Ht,m as Gt,T as Wt,h as kt,a as zt,b as Kt,d as Xt,A as _t,O as qt,x as Jt,g as Yt,w as jt,E as Qt,L as Zt,B as te,F as ee,I as ne,U as se,j as oe,V as re,M as ie,S as ae,k as ce,q as le,v as ue,z as fe,C as ge,D as de,G as pe,H as me}from"./BufferView.c86f5b8c.js";import{bg as he,gE as Ie,gF as $t,Y as S,dr as ut,gG as Ne,gH as $e,$ as k,gI as ft,gJ as X,gK as At,gL as Ae,gM as we,gN as gt,gO as Oe}from"./vendor.c414a8c9.js";import{O as f}from"./VertexAttribute.5551e0d8.js";import{C as D}from"./enums.de935fa5.js";import{t as Ee}from"./VertexElementDescriptor.d386088d.js";import"./types.0bd8fc95.js";function dt(t,e,n){const o=e/3,r=new Uint32Array(n+1),i=new Uint32Array(n+1),p=(s,a)=>{s<a?r[s+1]++:i[a+1]++};for(let s=0;s<o;s++){const a=t[3*s],g=t[3*s+1],d=t[3*s+2];p(a,g),p(g,d),p(d,a)}let c=0,m=0;for(let s=0;s<n;s++){const a=r[s+1],g=i[s+1];r[s+1]=c,i[s+1]=m,c+=a,m+=g}const l=new Uint32Array(6*o),u=r[n],I=(s,a,g)=>{if(s<a){const d=r[s+1]++;l[2*d]=a,l[2*d+1]=g}else{const d=i[a+1]++;l[2*u+2*d]=s,l[2*u+2*d+1]=g}};for(let s=0;s<o;s++){const a=t[3*s],g=t[3*s+1],d=t[3*s+2];I(a,g,s),I(g,d,s),I(d,a,s)}const N=(s,a)=>{const g=2*s,d=a-s;for(let A=1;A<d;A++){const E=l[g+2*A],L=l[g+2*A+1];let w=A-1;for(;w>=0&&l[g+2*w]>E;w--)l[g+2*w+2]=l[g+2*w],l[g+2*w+3]=l[g+2*w+1];l[g+2*w+2]=E,l[g+2*w+3]=L}};for(let s=0;s<n;s++)N(r[s],r[s+1]),N(u+i[s],u+i[s+1]);const h=new Int32Array(3*o),T=(s,a)=>s===t[3*a]?0:s===t[3*a+1]?1:s===t[3*a+2]?2:-1,$=(s,a)=>{const g=T(s,a);h[3*a+g]=-1},y=(s,a,g,d)=>{const A=T(s,a);h[3*a+A]=d;const E=T(g,d);h[3*d+E]=a};for(let s=0;s<n;s++){let a=r[s];const g=r[s+1];let d=i[s];const A=i[s+1];for(;a<g&&d<A;){const E=l[2*a],L=l[2*u+2*d];E===L?(y(s,l[2*a+1],L,l[2*u+2*d+1]),a++,d++):E<L?($(s,l[2*a+1]),a++):($(L,l[2*u+2*d+1]),d++)}for(;a<g;)$(s,l[2*a+1]),a++;for(;d<A;)$(l[2*u+2*d],l[2*u+2*d+1]),d++}return h}function H(t,e){return e.push(t.buffer),{buffer:t.buffer,layout:Se(t.layout)}}function Se(t){const e=new Array;return t.fields.forEach((n,o)=>{const r=lt(ct({},n),{constructor:wt(n.constructor)});e.push([o,r])}),{stride:t.stride,fields:e,fieldNames:t.fieldNames}}const Te=[bt,Ut,Ft,Rt,Bt,Ct,Ht,Gt,Wt,kt,zt,Kt,Xt,_t,qt,Jt,Yt,jt,Qt,Zt,te,ee,ne,se,oe,re,ie,ae,ce,le,ue,fe,ge,de,pe,me];function wt(t){return`${t.ElementType}_${t.ElementCount}`}const ye=new Map;Te.forEach(t=>ye.set(wt(t),t));function tt(t,e=0){const n=t.stride;return t.fieldNames.filter(o=>{const r=t.fields.get(o).optional;return!(r&&r.glPadding)}).map(o=>{const r=t.fields.get(o),i=r.constructor.ElementCount,p=Le(r.constructor.ElementType),c=r.offset,m=!(!r.optional||!r.optional.glNormalized);return new Ee(o,i,p,c,n,m,e)})}function Le(t){const e=ve[t];if(e)return e;throw new Error("BufferType not supported in WebGL")}const ve={u8:D.UNSIGNED_BYTE,u16:D.UNSIGNED_SHORT,u32:D.UNSIGNED_INT,i8:D.BYTE,i16:D.SHORT,i32:D.INT,f32:D.FLOAT},Ot=U().vec3f(f.POSITION).u16(f.COMPONENTINDEX).u16(f.U16PADDING),De=U().vec2u8(f.SIDENESS);tt(De);const Et=U().vec3f(f.POSITION0).vec3f(f.POSITION1).u16(f.COMPONENTINDEX).u8(f.VARIANTOFFSET,{glNormalized:!0}).u8(f.VARIANTSTROKE).u8(f.VARIANTEXTENSION,{glNormalized:!0}).u8(f.U8PADDING,{glPadding:!0}).u16(f.U16PADDING,{glPadding:!0}),_=Et.clone().vec3f(f.NORMAL),q=Et.clone().vec3f(f.NORMALA).vec3f(f.NORMALB);f.POSITION0,f.POSITION1,f.COMPONENTINDEX,f.VARIANTOFFSET,f.VARIANTSTROKE,f.VARIANTEXTENSION,f.NORMAL,f.NORMALA,f.NORMALB,f.SIDENESS;class St{updateSettings(e){this.settings=e,this.edgeHashFunction=e.reducedPrecision?Pe:Ve}write(e,n,o){const r=this.edgeHashFunction(o);C.seed=r;const i=C.getIntRange(0,255),p=C.getIntRange(0,this.settings.variants-1),c=.7,m=C.getFloat(),l=255*(.5*xe(-(1-Math.min(m/c,1))+Math.max(0,m-c)/(1-c),1.2)+.5);e.position0.setVec(n,o.position0),e.position1.setVec(n,o.position1),e.componentIndex.set(n,o.componentIndex),e.variantOffset.set(n,i),e.variantStroke.set(n,p),e.variantExtension.set(n,l)}trim(e,n){return e.slice(0,n)}}const et=new Float32Array(6),G=new Uint32Array(et.buffer),v=new Uint32Array(1);function Ve(t){const e=et;e[0]=t.position0[0],e[1]=t.position0[1],e[2]=t.position0[2],e[3]=t.position1[0],e[4]=t.position1[1],e[5]=t.position1[2],v[0]=5381;for(let n=0;n<G.length;n++)v[0]=31*v[0]+G[n];return v[0]}function Pe(t){const e=et;e[0]=M(t.position0[0]),e[1]=M(t.position0[1]),e[2]=M(t.position0[2]),e[3]=M(t.position1[0]),e[4]=M(t.position1[1]),e[5]=M(t.position1[2]),v[0]=5381;for(let n=0;n<G.length;n++)v[0]=31*v[0]+G[n];return v[0]}const pt=1e4;function M(t){return Math.round(t*pt)/pt}function xe(t,e){const n=t<0?-1:1;return Math.abs(t)**e*n}class J{constructor(){this.commonWriter=new St}updateSettings(e){this.commonWriter.updateSettings(e)}allocate(e){return _.createBuffer(e)}write(e,n,o){this.commonWriter.write(e,n,o),Ie(B,o.faceNormal0,o.faceNormal1),$t(B,B),e.normal.setVec(n,B)}trim(e,n){return this.commonWriter.trim(e,n)}}J.Layout=_,J.glLayout=tt(_,1);class Y{constructor(){this.commonWriter=new St}updateSettings(e){this.commonWriter.updateSettings(e)}allocate(e){return q.createBuffer(e)}write(e,n,o){this.commonWriter.write(e,n,o),e.normalA.setVec(n,o.faceNormal0),e.normalB.setVec(n,o.faceNormal1)}trim(e,n){return this.commonWriter.trim(e,n)}}Y.Layout=q,Y.glLayout=tt(q,1);const B=S(),C=new he,V=-1;var mt;function j(t,e,n,o=Be){const r=t.vertices.position,i=t.vertices.componentIndex,p=ut(o.anglePlanar),c=ut(o.angleSignificantEdge),m=Math.cos(c),l=Math.cos(p),u=Q.edge,I=u.position0,N=u.position1,h=u.faceNormal0,T=u.faceNormal1,$=Re(t),y=Fe(t),s=y.length/4,a=e.allocate(s);let g=0;const d=s,A=n.allocate(d);let E=0,L=0,w=0;const nt=Ne(0,s),F=new Float32Array(s);$e(F,(P,O,b)=>{r.getVec(y[4*O+0],I),r.getVec(y[4*O+1],N),b[O]=Oe(I,N)}),nt.sort((P,O)=>F[O]-F[P]);const st=new Array,ot=new Array;for(let P=0;P<s;P++){const O=nt[P],b=F[O],W=y[4*O+0],Lt=y[4*O+1],x=y[4*O+2],R=y[4*O+3],rt=R===V;if(r.getVec(W,I),r.getVec(Lt,N),rt)k(h,$[3*x+0],$[3*x+1],$[3*x+2]),ft(T,h),u.componentIndex=i.get(W),u.cosAngle=X(h,T);else{if(k(h,$[3*x+0],$[3*x+1],$[3*x+2]),k(T,$[3*R+0],$[3*R+1],$[3*R+2]),u.componentIndex=i.get(W),u.cosAngle=X(h,T),be(u,l))continue;u.cosAngle<-.9999&&ft(T,h)}L+=b,w++,rt||Me(u,m)?(e.write(a,g++,u),st.push(b)):Ue(u,p)&&(n.write(A,E++,u),ot.push(b))}const Tt=new Float32Array(st.reverse()),yt=new Float32Array(ot.reverse());return{regular:{instancesData:e.trim(a,g),lodInfo:{lengths:Tt}},silhouette:{instancesData:n.trim(A,E),lodInfo:{lengths:yt}},averageEdgeLength:L/w}}function Me(t,e){return t.cosAngle<e}function be(t,e){return t.cosAngle>e}function Ue(t,e){const n=Ae(t.cosAngle),o=Q.fwd,r=Q.ortho;return we(o,t.position1,t.position0),n*(X(At(r,t.faceNormal0,t.faceNormal1),o)>0?-1:1)>e}function Fe(t){const e=t.faces.length/3,n=t.faces,o=t.neighbors;let r=0;for(let c=0;c<e;c++){const m=o[3*c+0],l=o[3*c+1],u=o[3*c+2],I=n[3*c+0],N=n[3*c+1],h=n[3*c+2];r+=m===V||I<N?1:0,r+=l===V||N<h?1:0,r+=u===V||h<I?1:0}const i=new Int32Array(4*r);let p=0;for(let c=0;c<e;c++){const m=o[3*c+0],l=o[3*c+1],u=o[3*c+2],I=n[3*c+0],N=n[3*c+1],h=n[3*c+2];(m===V||I<N)&&(i[p++]=I,i[p++]=N,i[p++]=c,i[p++]=m),(l===V||N<h)&&(i[p++]=N,i[p++]=h,i[p++]=c,i[p++]=l),(u===V||h<I)&&(i[p++]=h,i[p++]=I,i[p++]=c,i[p++]=u)}return i}function Re(t){const e=t.faces.length/3,n=t.vertices.position,o=t.faces,r=z.v0,i=z.v1,p=z.v2,c=new Float32Array(3*e);for(let m=0;m<e;m++){const l=o[3*m+0],u=o[3*m+1],I=o[3*m+2];n.getVec(l,r),n.getVec(u,i),n.getVec(I,p),gt(i,i,r),gt(p,p,r),At(r,i,p),$t(r,r),c[3*m+0]=r[0],c[3*m+1]=r[1],c[3*m+2]=r[2]}return c}(function(t){t[t.SOLID=0]="SOLID",t[t.SKETCH=1]="SKETCH"})(mt||(mt={}));const Q={edge:{position0:S(),position1:S(),faceNormal0:S(),faceNormal1:S(),componentIndex:0,cosAngle:0},ortho:S(),fwd:S()},z={v0:S(),v1:S(),v2:S()},Be={anglePlanar:4,angleSignificantEdge:35};class Ce{async extract(e){const n=K(e),o=He(n),r=[n.data.buffer];return{result:Ge(o,r),transferList:r}}async extractComponentsEdgeLocations(e){const n=K(e),o=Z(n.data,n.skipDeduplicate,n.indices,n.indicesLength),r=j(o,Ke,Nt),i=[];return{result:H(r.regular.instancesData,i),transferList:i}}async extractEdgeLocations(e){const n=K(e),o=Z(n.data,n.skipDeduplicate,n.indices,n.indicesLength),r=j(o,ze,Nt),i=[];return{result:H(r.regular.instancesData,i),transferList:i}}}function He(t){const e=Z(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return ht.updateSettings(t.writerSettings),It.updateSettings(t.writerSettings),j(e,ht,It)}function K(t){return{data:Ot.createView(t.dataBuffer),indices:t.indicesType==="Uint32Array"?new Uint32Array(t.indicesBuffer):t.indicesType==="Uint16Array"?new Uint16Array(t.indicesBuffer):void 0,indicesLength:t.indicesLength,writerSettings:t.writerSettings,skipDeduplicate:t.skipDeduplicate}}function Ge(t,e){return e.push(t.regular.lodInfo.lengths.buffer),e.push(t.silhouette.lodInfo.lengths.buffer),{regular:{instancesData:H(t.regular.instancesData,e),lodInfo:{lengths:t.regular.lodInfo.lengths.buffer}},silhouette:{instancesData:H(t.silhouette.instancesData,e),lodInfo:{lengths:t.silhouette.lodInfo.lengths.buffer}},averageEdgeLength:t.averageEdgeLength}}function Z(t,e,n,o){if(e)return{faces:n,facesLength:o,neighbors:dt(n,o,t.count),vertices:t};const r=Mt(t.buffer,t.stride/4,{originalIndices:n,originalIndicesLength:o}),i=dt(r.indices,o,r.uniqueCount);return{faces:r.indices,facesLength:r.indices.length,neighbors:i,vertices:Ot.createView(r.buffer)}}const ht=new J,It=new Y;class We{allocate(e){return Xe.createBuffer(e)}trim(e,n){return e.slice(0,n)}write(e,n,o){e.position0.setVec(n,o.position0),e.position1.setVec(n,o.position1)}}class ke{allocate(e){return _e.createBuffer(e)}trim(e,n){return e.slice(0,n)}write(e,n,o){e.position0.setVec(n,o.position0),e.position1.setVec(n,o.position1),e.componentIndex.set(n,o.componentIndex)}}const ze=new We,Ke=new ke,Nt={allocate:()=>null,write:()=>{},trim:()=>null},Xe=U().vec3f(f.POSITION0).vec3f(f.POSITION1),_e=U().vec3f(f.POSITION0).vec3f(f.POSITION1).u16(f.COMPONENTINDEX).u16(f.U16PADDING,{glPadding:!0});function sn(){return new Ce}export{Ce as EdgeProcessingWorker,sn as default,He as extract,_e as extractComponentsEdgeLocationsLayout,Xe as extractEdgeLocationsLayout};
